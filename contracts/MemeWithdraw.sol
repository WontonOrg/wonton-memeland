// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/**
 * @title MemeWithdraw
 * @dev Contract for handling meme token withdrawals with backend signature verification
 * Users can withdraw their meme tokens using signatures generated by the backend
 */
contract MemeWithdraw is Ownable, ReentrancyGuard, Pausable {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    // Events
    event TokenWithdrawn(
        address indexed user,
        address indexed tokenAddress,
        uint256 amount,
        uint256 nonce,
        uint256 timestamp
    );

    event SignerUpdated(
        address indexed oldSigner,
        address indexed newSigner
    );

    event TokenAdded(
        address indexed tokenAddress,
        string symbol
    );

    event TokenRemoved(
        address indexed tokenAddress
    );

    event TokenDeposited(
        address indexed tokenAddress,
        uint256 amount
    );

    // State variables
    address public signerAddress;
    
    // Track nonces for each user to prevent replay attacks
    mapping(address => uint256) public userNonces;
    
    // Track supported tokens
    mapping(address => bool) public supportedTokens;
    
    // Track total withdrawn for each user and token
    mapping(address => mapping(address => uint256)) public userTokenWithdrawals;

    constructor(address _signerAddress) Ownable(msg.sender) {
        require(_signerAddress != address(0), "Invalid signer address");
        signerAddress = _signerAddress;
    }

    /**
     * @dev Update the signer address (backend signature authority)
     * @param _newSigner New signer address
     */
    function updateSigner(address _newSigner) external onlyOwner {
        require(_newSigner != address(0), "Invalid signer address");
        address oldSigner = signerAddress;
        signerAddress = _newSigner;
        emit SignerUpdated(oldSigner, _newSigner);
    }

    /**
     * @dev Add a supported token
     * @param _tokenAddress Token contract address
     * @param _symbol Token symbol (for events)
     */
    function addToken(address _tokenAddress, string memory _symbol) external onlyOwner {
        require(_tokenAddress != address(0), "Invalid token address");
        require(!supportedTokens[_tokenAddress], "Token already supported");
        
        supportedTokens[_tokenAddress] = true;
        emit TokenAdded(_tokenAddress, _symbol);
    }

    /**
     * @dev Remove a supported token
     * @param _tokenAddress Token contract address
     */
    function removeToken(address _tokenAddress) external onlyOwner {
        require(supportedTokens[_tokenAddress], "Token not supported");
        
        supportedTokens[_tokenAddress] = false;
        emit TokenRemoved(_tokenAddress);
    }

    /**
     * @dev Deposit tokens into the contract for withdrawal pool
     * @param _tokenAddress Token contract address
     * @param _amount Amount to deposit
     */
    function depositToken(address _tokenAddress, uint256 _amount) external onlyOwner {
        require(supportedTokens[_tokenAddress], "Token not supported");
        require(_amount > 0, "Amount must be greater than 0");
        
        IERC20 token = IERC20(_tokenAddress);
        require(token.transferFrom(msg.sender, address(this), _amount), "Transfer failed");
        
        emit TokenDeposited(_tokenAddress, _amount);
    }

    /**
     * @dev Main withdrawal function - users call this with backend signature
     * @param _tokenAddress Address of the token to withdraw
     * @param _amount Amount of tokens to withdraw
     * @param _nonce Unique nonce for this withdrawal (must match user's current nonce)
     * @param _signature Backend signature authorizing this withdrawal
     */
    function withdraw(
        address _tokenAddress,
        uint256 _amount,
        uint256 _nonce,
        bytes memory _signature
    ) external nonReentrant whenNotPaused {
        require(supportedTokens[_tokenAddress], "Token not supported");
        require(_amount > 0, "Amount must be greater than 0");
        require(_nonce == userNonces[msg.sender], "Invalid nonce");

        // Verify signature
        bytes32 messageHash = keccak256(abi.encodePacked(
            msg.sender,
            _tokenAddress,
            _amount,
            _nonce,
            address(this) // Include contract address to prevent cross-contract replay
        ));
        
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address recoveredSigner = ethSignedMessageHash.recover(_signature);
        
        require(recoveredSigner == signerAddress, "Invalid signature");

        // Increment nonce to prevent replay
        userNonces[msg.sender]++;

        // Transfer tokens
        IERC20 token = IERC20(_tokenAddress);
        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= _amount, "Insufficient contract balance");

        require(token.transfer(msg.sender, _amount), "Token transfer failed");

        // Update withdrawal tracking
        userTokenWithdrawals[msg.sender][_tokenAddress] += _amount;

        emit TokenWithdrawn(msg.sender, _tokenAddress, _amount, _nonce, block.timestamp);
    }

    /**
     * @dev Batch withdrawal function - withdraw multiple tokens at once
     * @param _tokenAddresses Array of token addresses
     * @param _amounts Array of amounts (must match length of _tokenAddresses)
     * @param _nonce Unique nonce for this batch withdrawal
     * @param _signature Backend signature authorizing this batch withdrawal
     */
    function batchWithdraw(
        address[] memory _tokenAddresses,
        uint256[] memory _amounts,
        uint256 _nonce,
        bytes memory _signature
    ) external nonReentrant whenNotPaused {
        require(_tokenAddresses.length == _amounts.length, "Array length mismatch");
        require(_tokenAddresses.length > 0, "Empty arrays");
        require(_nonce == userNonces[msg.sender], "Invalid nonce");

        // Verify all tokens are supported and amounts are valid
        for (uint256 i = 0; i < _tokenAddresses.length; i++) {
            require(supportedTokens[_tokenAddresses[i]], "Token not supported");
            require(_amounts[i] > 0, "Amount must be greater than 0");
        }

        // Verify signature
        bytes32 messageHash = keccak256(abi.encodePacked(
            msg.sender,
            _tokenAddresses,
            _amounts,
            _nonce,
            address(this)
        ));
        
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address recoveredSigner = ethSignedMessageHash.recover(_signature);
        
        require(recoveredSigner == signerAddress, "Invalid signature");

        // Increment nonce to prevent replay
        userNonces[msg.sender]++;

        // Transfer all tokens
        for (uint256 i = 0; i < _tokenAddresses.length; i++) {
            IERC20 token = IERC20(_tokenAddresses[i]);
            uint256 contractBalance = token.balanceOf(address(this));
            require(contractBalance >= _amounts[i], "Insufficient contract balance");

            require(token.transfer(msg.sender, _amounts[i]), "Token transfer failed");

            // Update withdrawal tracking
            userTokenWithdrawals[msg.sender][_tokenAddresses[i]] += _amounts[i];

            emit TokenWithdrawn(msg.sender, _tokenAddresses[i], _amounts[i], _nonce, block.timestamp);
        }
    }

    /**
     * @dev Get user's current nonce
     * @param _user User address
     */
    function getUserNonce(address _user) external view returns (uint256) {
        return userNonces[_user];
    }

    /**
     * @dev Get user's total withdrawals for a specific token
     * @param _user User address
     * @param _tokenAddress Token address
     */
    function getUserWithdrawals(address _user, address _tokenAddress) external view returns (uint256) {
        return userTokenWithdrawals[_user][_tokenAddress];
    }

    /**
     * @dev Check if token is supported
     * @param _tokenAddress Token address
     */
    function isTokenSupported(address _tokenAddress) external view returns (bool) {
        return supportedTokens[_tokenAddress];
    }

    /**
     * @dev Get contract's balance of a specific token
     * @param _tokenAddress Token address
     */
    function getTokenBalance(address _tokenAddress) external view returns (uint256) {
        IERC20 token = IERC20(_tokenAddress);
        return token.balanceOf(address(this));
    }

    /**
     * @dev Emergency withdraw function - owner can withdraw tokens in case of emergency
     * @param _tokenAddress Token to withdraw
     * @param _amount Amount to withdraw
     */
    function emergencyWithdraw(address _tokenAddress, uint256 _amount) external onlyOwner {
        require(_tokenAddress != address(0), "Invalid token address");
        
        IERC20 token = IERC20(_tokenAddress);
        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= _amount, "Insufficient balance");

        require(token.transfer(owner(), _amount), "Transfer failed");
    }

    /**
     * @dev Pause withdrawals
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpause withdrawals
     */
    function unpause() external onlyOwner {
        _unpause();
    }
}
